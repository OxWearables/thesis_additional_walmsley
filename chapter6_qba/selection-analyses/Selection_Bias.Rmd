---
title: "Selection Bias"
author: "R-Walmsley"
date: "2022-05-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Set up names
```{r}
name_of_current_run <- "selection_second_attempt"
# NAME WHERE DATA IS
input_loc <- "../../../../paperRW2021/"
```

# Load packages
```{r}
lapply(c("ggplot2", "survival", "table1", "mice"), library, character.only = TRUE)
source("../../useful_functions/round_2_dp.R")
source("../../useful_functions/consistent_theme.R")
```

# Load data 
```{r}
df_all <- readRDS(paste0("data/", name_of_current_run, "_ready_to_use.RDS"))
df_in <- readRDS(paste0(input_loc, "epiAnalysis/inputData/2021-06-17check_messages_ready_to_use.RDS"))
df_other <- readRDS("../../chapter3_ukb/outputs/processed_data_for_sel_bias.RDS")
```

# Variable set up 
```{r}
vars_orig <- c("sex", "ethnicity", "smoking", "alcohol", "fruit_and_veg_cats", "red_and_processed_meat_cats", "oily_fish", "TownsendDeprIndexRecruit", "education_cats")
vars_health_orig <- c("BMI", "poor_health", "meds")
vars_sr_act <-   c("Self_reported_MPA",
  "Self_reported_VPA", 
  "Job_involves_walking_standing",
  "Job_involves_activity")
vars_biom_tab_only <- c( "Systolic_blood_pressure",
  "HbA1c",
  "C_Reactive_Protein",
  "LDL_cholesterol",
  "HDL_cholesterol",
  "Triglycerides")

var_list_minus_age <- c(vars_orig, vars_health_orig, vars_sr_act, vars_biom_tab_only)
```

# Deal with job status 
```{r}
emp_status <- rep(NA, times = nrow(df_other))
emp_status[grepl("In paid employment or self-employed", df_other$employed_i0)] <- "Employed"
emp_status[!grepl("In paid employment or self-employed", df_other$employed_i0) & (grepl( "Retired|Looking after home and/or family|Unemployed|Unable to work because of sickness or disability|Doing unpaid or voluntary work|Full or part-time student", df_other$employed_i0))] <- "Not_employed"
emp_status[!(emp_status %in% c("Employed", "Not_employed"))] <- NA

for (var in vars_sr_act[3:4]){
  df_other[, var][emp_status == "Not_employed"] <- "Not_in_employment"
  }
```

# Merge additional columns into df_all
```{r}
df_all <- merge(df_all, df_other[,c(
  "eid", vars_sr_act, vars_biom_tab_only)], by = "eid", all.x = TRUE) # We are left joining here because df_all has already had exclusion of people with prevalent CVD
```

Note we do have an interesting question about prevalent CVD, because there could be people who "shouldn't" be here because they either have CVD or die before the start of the accelerometry study. 

- Some studies do exclude these I think... maybe I should do that. 
- But, this is a conservative assumption so it's probably ok. 

# Calculate weights
Add indicator variable of presence in analytic dataset: 
```{r}
df_all$in_analytic_sample <- df_all$eid %in% df_in$eid
```

Do some preprocessing to: 

- ensure consistent treatment of missingness
- put most frequent category as reference
- visualise continuous variables and add a log-transformed version  
```{r}
for (var in c("baseline_age", var_list_minus_age)){
  print(var)
  df_all[, var][df_all[, var] == ""] <- NA
  if (!(var %in% c("baseline_age", "BMI", "TownsendDeprIndexRecruit", vars_biom_tab_only, vars_sr_act[c(1, 2)]))){
    tab <- as.data.frame(table(df_all[, var]))
    ref <- as.character(tab$Var[tab$Freq == max(tab$Freq)])
    df_all[, var] <- relevel(factor(df_all[, var]), ref = ref)
  }
  if (var %in% c("baseline_age", "BMI", "TownsendDeprIndexRecruit", vars_biom_tab_only, vars_sr_act[c(1, 2)])){
    print(hist(as.numeric(df_all[, var]), main = var))
    print(hist(log(as.numeric(df_all[, var]) + .1), main = paste0("log(x+1)" , var)))
    df_all[, paste0("log_", var)] <- log(as.numeric(df_all[, var]) + .1)
  }
}
df_all$baseline_age_ten_years <- as.double(df_all$baseline_age)/(365.25*10)
df_all$Self_reported_MPA <- as.double(df_all$Self_reported_MPA)
df_all$Self_reported_VPA <- as.double(df_all$Self_reported_VPA)

```

Set up for logistic regression model: 
```{r}
# List variables with log transformation where appropriate
var_list_imp <-
  c(
    "in_analytic_sample",
    "baseline_age_ten_years",
    "sex",
    "ethnicity",
    "smoking",
    "alcohol",
    "fruit_and_veg_cats",
    "red_and_processed_meat_cats",
    "oily_fish",
    "TownsendDeprIndexRecruit",
    "education_cats",
    "log_BMI",
    "poor_health",
    "meds",
    "log_Self_reported_MPA",
    "log_Self_reported_VPA",
    "Job_involves_walking_standing",
    "Job_involves_activity",
    "log_Systolic_blood_pressure",
    "log_HbA1c",
    "log_C_Reactive_Protein",
    "log_LDL_cholesterol",
    "log_HDL_cholesterol",
    "log_Triglycerides"
  )
print(paste0(var_list_imp[2:length(var_list_imp)], collapse = "+")) # get the variables for use in models
```

Imputation: 
```{r}
print(Sys.time())
imp <-
  parlmice(
    df_all[, var_list_imp],
    n.core = 6,
    m = 6,
    n.imp.core = 1,
    print = F
  ) # parlmice is a parallelised version of mice
print(Sys.time())
```

Model in whole dataset: 
```{r}
# Do model in whole dataset
log_inc <-
  with(
    imp,
    glm(
      in_analytic_sample ~ baseline_age_ten_years + sex + ethnicity + smoking +
        alcohol + fruit_and_veg_cats + red_and_processed_meat_cats + oily_fish +
        TownsendDeprIndexRecruit + education_cats + log_BMI + poor_health + meds +
        log_Self_reported_MPA + log_Self_reported_VPA + Job_involves_walking_standing +
        Job_involves_activity + log_Systolic_blood_pressure + log_HbA1c + log_C_Reactive_Protein +
        log_LDL_cholesterol + log_HDL_cholesterol + log_Triglycerides,
      family = binomial
    )
  )

# Pool to get coefficients
pool_model <- pool(log_inc)

summary(pool_model)

# Grab coefficients
mod_coef <- summary(pool_model, conf.int = TRUE, exponentiate = TRUE)[, c("term", "estimate", "2.5 %", "97.5 %")]
tab_wt_model_f <- cbind(mod_coef[, 1, drop = FALSE], format(round(mod_coef[, 2:4], digits = 2), nsmall = 2))
tab_wt_model_f$`OR (CI)` <- paste0(tab_wt_model_f[, 2], " (", tab_wt_model_f[, 3], ", ", tab_wt_model_f[, 4], ")")
t <-
   knitr::kable(
     tab_wt_model_f[, c("term", "OR (CI)")],
     format = "latex",
     booktabs = TRUE,
     longtable = TRUE
 )
 write(t, "plots/table-weight-model.tex")
```

Do logistic regression model in each imputed dataset:
```{r}
lp_glm <- data.frame(matrix(nrow = nrow(df_all), ncol = 0)) # set up dataframe to record

# Do logistic regression model in each dataset and predict from it
for (i in 1:6){
  loc_dat <- complete(imp, i)
  print(nrow(loc_dat))
  loc_glm <-glm(
    in_analytic_sample ~ baseline_age_ten_years + sex + ethnicity + smoking +
        alcohol + fruit_and_veg_cats + red_and_processed_meat_cats + oily_fish +
        TownsendDeprIndexRecruit + education_cats + log_BMI + poor_health + meds +
        log_Self_reported_MPA + log_Self_reported_VPA + Job_involves_walking_standing +
        Job_involves_activity + log_Systolic_blood_pressure + log_HbA1c + log_C_Reactive_Protein +
        log_LDL_cholesterol + log_HDL_cholesterol + log_Triglycerides,
    family = binomial, data = loc_dat)
  loc_p <- predict(loc_glm, newdata =loc_dat, type = "link")
  lp_glm[, paste0("lp_", i)] <- loc_p
  rm(loc_dat, loc_glm, loc_p)
}


lp_av <- apply(lp_glm, 1, mean)
p_av <- exp(lp_av)/(1+exp(lp_av))

df_all$selec_prob <- p_av
```

... There could be an issue if there is any scrambling of rows, but we should be able to see this from table. 

Calculate Stabilised Trimmed Inverse Probability of Selection Weights: 
```{r}
selec_prob_all <-
  nrow(df_in) / nrow(df_all) # Everyone in df_all should be included in model due to imputation
df_all$inverse_wt_stab <- selec_prob_all / df_all$selec_prob # Stabilisation

# Add to analytic data
df_in <-
  merge(df_in, df_all[, c("eid", "inverse_wt_stab", "selec_prob", vars_sr_act,  vars_biom_tab_only)], by = "eid")


# Stabilisation changes the effective population size
# Before: 
sum(1/df_in$selec_prob)
# After:
sum(1/df_in$inverse_wt_stab)

# Trim weights: 
qt <- quantile(df_in$inverse_wt_stab, 0.99)
df_in$inverse_wt_stab_trim <- ifelse(df_in$inverse_wt_stab > qt, qt, df_in$inverse_wt_stab)
```

## Check these weights look reasonable! 

XXX TODO Add additional variables to this table
Set up variables for table: 
```{r}
df_in$pa <- df_in$acc.overall.avg
df_in$age_entry_years <- as.double(df_in$age_entry)/365.25
df_in <- merge(df_in, df_all[, c("eid", vars_biom_tab_only, vars_sr_act)], all.x = TRUE)
df_in$inverse_wt_quarters <- cut(df_in$inverse_wt_stab_trim, quantile(df_in$inverse_wt_stab_trim), c("Q1 - Lowest weight", "Q2", "Q3", "Q4 - Highest weight"))


# Units
units(df_in$age_entry_years) <- "years"
units(df_in$HbA1c) <- "mmol/mol"
units(df_in$C_Reactive_Protein) <- "mg/L"
units(df_in$BMI) <- "kg/m^2"
units(df_in$LDL_cholesterol) <- "mmol/L"
units(df_in$HDL_cholesterol) <- "mmol/L"
units(df_in$Triglycerides) <- "mmol/L"


# Labels
label(df_in$pa) <- "Overall activity"
units(df_in$pa) <- "mg"
label(df_in$age_entry_years) <- "Age at accelerometer wear"
label(df_in$sex) <- "Sex"
label(df_in$ethnicity) <- "Ethnicity"
label(df_in$smoking) <- "Smoking status"
label(df_in$alcohol) <- "Alcohol consumption frequency"
label(df_in$fruit_and_veg_cats) <- "Daily fruit and vegetable consumption"
label(df_in$TownsendDeprIndexRecruit) <- "Townsend Deprivation Index"
label(df_in$education_cats) <- "Qualifications"
label(df_in$poor_health) <- "Poor self-rated health"
label(df_in$meds) <- "Medications for diabetes, cholesterol or blood pressure"
label(df_in$BMI) <- "BMI"

# Column labels
for (var in c(vars_sr_act, vars_biom_tab_only)) {
  label(df_in[, var]) <- gsub("_", " ", var)
}

```

Prep variables for table:
```{r}
vs <- c("pa", "age_entry_years", var_list_minus_age)
vars_table_labels <- as.list(rep(NA, times = length(vs)))
for (i in 1:length(vs)) {
    var <- vs[i]
    label <- label(df_in[, var])
    unit <- units(df_in[, var])
    if (!is.null(unit)) {
      desc <- paste0(label, " (", unit, ")")
    }
    else {
      desc <- label
    }
    vars_table_labels[[i]] <- desc
}
names(vars_table_labels) <- vs
```

Prepare to write table:
```{r}
# CATEGORICAL RENDERER
my_render_cat <- function(x) {
  c("", sapply(stats.default(x), function(y)
    with(y,
         paste0(
           formatC(FREQ, big.mark = ","),
           " (",
           format(round(PCT, digits = 0), nsmall = 0),
           "%)"
         ))))
}

# CATEGORICAL RENDERER
my_render_cont <- function(x){
  with(
    stats.apply.rounding(stats.default(x)),
    c(
      "",
      `Mean (SD)` = sprintf("%s (%s)", MEAN, SD),
      `Median [Q1, Q3]` = sprintf("%s [%s, %s]",
                                    MEDIAN, Q1, Q3)
    )
  )
}
```

Write table:
```{r}
tab_wts <-
  table1(c(list("Overall" = df_in), 
                split(df_in, df_in$inverse_wt_quarters)),
    labels = list(variables = vars_table_labels),
    render.categorical = my_render_cat, 
    render.cont = my_render_cont
  )
t <-
  t1kable(
    tab_wts,
    format = "latex",
    booktabs = TRUE,
    longtable = TRUE
  )
write(t,
     "plots/selection-wts.tex")


```


## Run weighted Cox model
```{r}
rot_list <- list(
  "sleep" = c("sleep", "SB", "LIPA", "MVPA"),
  "SB" = c("SB", "sleep", "LIPA", "MVPA"),
  "LIPA" = c("LIPA", "sleep", "SB",  "MVPA"),
  "MVPA" = c("MVPA", "sleep", "SB", "LIPA")
)

cm <- epicoda::comp_mean(df_in, rot_list[[1]])
act_vars <- as.matrix(df_in[, rot_list[[1]]])
rep_val <- min(act_vars[act_vars != 0])
act_vars_z <-
  zCompositions::lrEM(act_vars, label = 0, rep(rep_val, length.out = 4))
colnames(act_vars_z) <- rot_list[[1]]


rec_dat <- data.frame(matrix(nrow = 8, ncol = 6))
colnames(rec_dat) <-
  c("Behaviour",
    "Difference",
    "Model",
    "HR",
    "LowerCI",
    "UpperCI")

for (i in 1:length(rot_list)) {
  # set up
  comp_labels <- rot_list[[i]]
  comp_name <- names(rot_list)[i]

  # set up for later looking at transformation
  if (comp_name == "MVPA") {
    diff <- 1 / (24 * 3)
  } else {
    diff <- 1 / 24
  }
  pivvar <- cm[, comp_name]
  pivvarnew <- pivvar + diff

  othvarname <- colnames(cm)[colnames(cm) != comp_name]
  othvar <- cm[, othvarname]
  othvarnew <- othvar
  for (var in othvarname) {
    othvarnew[, var] <-
      othvar[, var] - diff * othvar[, var] / sum(othvar)
  }

  ilr_old <-
    sqrt(3 / 4) * log(pivvar / (othvar[, 1] * othvar[, 2] * othvar[, 3]) ^
                        (1 / 3))
  ilr_new <-
    sqrt(3 / 4) * log(pivvarnew / (othvarnew[, 1] * othvarnew[, 2] * othvarnew[, 3]) ^
                        (1 / 3))
  ilr_diff <- ilr_new - ilr_old

  # do transformation
  piv_c <-
    as.data.frame(robCompositions::pivotCoord(act_vars_z[, comp_labels]))
  colnames(piv_c) <- c("piv1", "piv2", "piv3")

  # make new data with these variables
  loc <- cbind(df_in, piv_c)

  # basic cox model
  cox_mod_simple <- coxph(
    Surv(age_entry, age_exit, CVD_event) ~
      strata(sex) + ethnicity + smoking + alcohol +
      fruit_and_veg_cats + oily_fish +
      red_and_processed_meat_cats + education_cats +
      TDI_quartiles +
      piv1 + piv2 + piv3,
    data = loc
  )
  assign(paste0("cox_", comp_name), cox_mod_simple)
  vals <- summary(cox_mod_simple)$conf.int["piv1", c(1, 3, 4)]
  assign(paste0("cox_pv_", comp_name), round_2_dp(vals))
  HRs <- vals ^ ilr_diff
  assign(paste0("cox_sub_", comp_name), HRs)
  rec_dat[(i - 1) * 2 + 1,] <- c(comp_name, diff, "unweighted", HRs)
  
  # Weighted Cox model 
  cox_mod_weighted <- coxph(
    Surv(age_entry, age_exit, CVD_event) ~
      strata(sex) + ethnicity + smoking + alcohol +
      fruit_and_veg_cats + oily_fish +
      red_and_processed_meat_cats + education_cats +
      TDI_quartiles +
      piv1 + piv2 + piv3, weights = inverse_wt_stab_trim,
    data = loc, id = eid, robust = TRUE # see notes on coxph function, robust = TRUE (i.e. robust SEs) needed if weights are sampling weights. I'm still not sure this is correct! Although it looks good based on later research
  )
  assign(paste0("cox_weighted_", comp_name), cox_mod_weighted)
  vals <- summary(cox_mod_weighted)$conf.int["piv1", c(1, 3, 4)]
  assign(paste0("cox_pv_weighted_", comp_name), round_2_dp(vals))
  HRs <- vals ^ ilr_diff
  assign(paste0("cox_sub_weighted_", comp_name), HRs)
  rec_dat[(i - 1) * 2 + 2,] <- c(comp_name, diff, "weighted", HRs)
}
```


Prep plot: 
```{r}
for (var in c("HR", "LowerCI", "UpperCI")) {
  rec_dat[, var] <- as.numeric(rec_dat[, var])
}

rdc <- rec_dat # This just saves the df so it's not a pain to get back if needed

## Make forest plot --------------------------------------------------------------

### This part is admin for labels etc --------------------------------------------
rec_dat$label <-
  paste0(
    round_2_dp(rec_dat$HR),
    " (",
    round_2_dp(rec_dat$LowerCI),
    ", ",
    round_2_dp(rec_dat$UpperCI),
    ")"
  )

rec_dat$Behaviour <-
  factor(rec_dat$Behaviour, ordered = TRUE, levels = rot_list[[1]])
rec_dat$BehaviourDet <- plyr::revalue(
  rec_dat$Behaviour,
  c(
    "MVPA" = "MVPA (extra 20 min/day)",
    "LIPA" = "LIPA (extra 1 hr/day)",
    "SB" = "SB (extra 1 hr/day)",
    "sleep" = "Sleep (extra 1 hr/day)"
  )
)

rec_dat$Model <-
  factor(rec_dat$Model,
         ordered = TRUE,
         c("weighted", "unweighted"))
my_cols <- c("darkred", "black")
```

Make plot: 
```{r}
### Make plot----------------------------------------------------------------------
p <- # DATA AND AESTHETICS
  ggplot(data = rec_dat,
            aes(
              x = HR,
              y = BehaviourDet ,
              colour= Model,
              group = Model,
              label = label
            )) +
  # GEOMS
  geom_pointrange(position = position_dodge(0.6), aes(xmin = LowerCI, xmax = UpperCI), size = 1, shape = 18) +
  geom_text(
    size = 4.5,
    aes(x = 1.18, y = BehaviourDet, label = label),
    position = position_dodge(0.6),
    colour = "black", 
    fontface = "bold"
  ) +
  geom_vline(xintercept = 1, size = 0.75) +

  # SCALES
  scale_x_continuous(trans = "log10", breaks = c(0.9, 0.95, 1, 1.05)) +
  scale_color_manual(values = my_cols, guide = guide_legend(reverse = TRUE)) +
 # scale_shape_manual(values = c(18, 20), guide = "none" ) +

  # CONSISTENT THEME
  consistent_theme

## save plot to file----------------------------------------------------------------------------------------------
svg(
  "plots/thesis-selection.svg",
  width = 10,
  height = 5
)
print(p)
dev.off()
```

This isn't always true:
```{r}
summary(cox_mod_simple)
summary(cox_mod_weighted)
```

Looking at % change in coef: 
```{r}
cs <- cox_mod_simple$coefficients
cw <- cox_mod_weighted$coefficients
print(100*(cw-cs)/cs)
print(cw-cs)

exp(cs[["ethnicityBlack"]])
exp(cw[["ethnicityBlack"]])
```
